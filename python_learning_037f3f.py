################################################################################
# LEARN PYTHON: VISUALIZING THE MANDELBROT FRACTAL WITH TURTLE AND NUMPY
#
# This tutorial will teach you how to:
# 1. Understand the basic concept of the Mandelbrot set.
# 2. Use NumPy for efficient numerical calculations.
# 3. Utilize Python's turtle module for graphical visualization.
# 4. Combine these tools to create an interactive visualization of the Mandelbrot fractal.
#
# We will focus on the core logic of calculating Mandelbrot set members
# and then rendering them visually.
################################################################################

import turtle
import numpy as np

# --- Configuration ---
# Define the screen dimensions for our turtle graphics.
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 800

# Define the region of the complex plane to explore.
# These are the boundaries for our visualization.
# The Mandelbrot set is typically found within these ranges.
RE_START = -2.0
RE_END = 1.0
IM_START = -1.5
IM_END = 1.5

# Maximum number of iterations to determine if a point escapes.
# A higher number of iterations reveals more detail but takes longer to compute.
MAX_ITERATIONS = 100

# --- Mandelbrot Calculation Logic ---

def mandelbrot(c, max_iter):
    """
    Calculates whether a complex number 'c' belongs to the Mandelbrot set.

    The Mandelbrot set is defined by the recurrence relation:
    z_(n+1) = z_n^2 + c
    starting with z_0 = 0.

    A complex number 'c' is in the Mandelbrot set if the sequence
    generated by this relation remains bounded (i.e., does not go to infinity).
    We approximate this by checking if the magnitude of z_n exceeds 2.
    If it exceeds 2, the sequence will diverge to infinity.

    Args:
        c (complex): The complex number to test.
        max_iter (int): The maximum number of iterations to perform.

    Returns:
        int: The number of iterations it took for the sequence to escape,
             or max_iter if it did not escape within the limit.
    """
    z = 0j  # Initialize z to 0 (a complex number with real and imaginary parts as 0)
    for i in range(max_iter):
        z = z*z + c  # Apply the Mandelbrot recurrence relation
        # Check if the magnitude of z has exceeded 2.
        # abs(z) calculates the magnitude (distance from origin) of a complex number.
        if abs(z) > 2.0:
            return i  # The point escaped, return the iteration count
    return max_iter  # The point did not escape within max_iter, it's likely in the set

# --- Visualization Setup ---

def setup_turtle():
    """
    Sets up the turtle screen and the drawing turtle.
    Initializes the screen and prepares the turtle for drawing.
    """
    screen = turtle.Screen()
    screen.setup(SCREEN_WIDTH, SCREEN_HEIGHT)
    screen.bgcolor("black")  # Set background to black for better contrast
    screen.title("Mandelbrot Fractal Explorer")
    screen.tracer(0)  # Turn off screen updates to speed up drawing

    t = turtle.Turtle()
    t.hideturtle()  # Hide the turtle icon
    t.speed(0)  # Set the fastest drawing speed
    t.penup()  # Lift the pen so it doesn't draw while moving to positions

    return screen, t

# --- Drawing the Mandelbrot Set ---

def draw_mandelbrot(t, width, height, re_start, re_end, im_start, im_end, max_iter):
    """
    Draws the Mandelbrot fractal on the turtle screen.

    This function iterates through each pixel of the screen, maps it to a
    complex number in the specified region of the complex plane, calculates
    whether that complex number belongs to the Mandelbrot set, and then
    colors the pixel accordingly.

    Args:
        t (turtle.Turtle): The turtle object for drawing.
        width (int): The width of the drawing area.
        height (int): The height of the drawing area.
        re_start (float): The starting real coordinate.
        re_end (float): The ending real coordinate.
        im_start (float): The starting imaginary coordinate.
        im_end (float): The ending imaginary coordinate.
        max_iter (int): The maximum number of iterations for Mandelbrot calculation.
    """
    # Calculate the step size for real and imaginary parts.
    # This determines how finely we sample the complex plane.
    re_step = (re_end - re_start) / width
    im_step = (im_end - im_start) / height

    # Loop through each pixel (x, y) on the screen.
    # We iterate from top to bottom (height) and left to right (width).
    for y in range(height):
        for x in range(width):
            # Map screen coordinates (x, y) to a complex number c.
            # The real part corresponds to the x-coordinate and the imaginary
            # part corresponds to the y-coordinate.
            # We adjust for the starting coordinates and step sizes.
            re = re_start + x * re_step
            im = im_start + y * im_step
            c = complex(re, im)

            # Calculate the number of iterations for this complex number.
            iterations = mandelbrot(c, max_iter)

            # Determine the color based on the number of iterations.
            # If iterations == max_iter, the point is considered to be in the set (colored black).
            # Otherwise, the color is determined by the number of iterations, creating the fractal patterns.
            if iterations == max_iter:
                color = "black"  # Points inside the set are black
            else:
                # A simple color mapping: use the iteration count to create a gradient.
                # We scale the iteration count to a value between 0 and 1 for color calculation.
                # This is a basic way to visualize escape times. More sophisticated colormaps exist.
                color_value = iterations / max_iter
                # We can use turtle's colormode for RGB values (0-1) or (0-255).
                # Let's use a grayscale approach for simplicity.
                # For more vibrant colors, you'd map iterations to specific RGB values.
                # Example: color_rgb = (color_value * 255, color_value * 100, color_value * 50)
                # For simplicity, we'll use a hue-based approach if the turtle supports it,
                # or a simple grayscale mapping.
                # Let's map to a rainbow-like effect by adjusting R, G, B based on iteration.
                # A common technique is to map iterations to a hue in HSV color space.
                # For simplicity here, let's stick to a grayscale or limited color range.
                # A common approach for visualization is to map iterations to a value on a scale.
                # For example, mapping to shades of blue:
                # The exact mapping can significantly change the visual appeal.
                # This is a simple example of mapping to a spectrum of colors.
                # We can use the iteration count to determine the intensity or hue.
                # For a basic visualization:
                # If iterations is low, color it bright, if high, color it dark.
                # Let's map the iteration count to a color intensity.
                # A simple way is to use the iteration count directly for a color component.
                # Example: color = (iterations % 256, iterations % 100, iterations % 50)
                # We need to ensure turtle's colormode is set to 255 if we use it directly.
                # turtle.colormode(255) would be needed for that.
                # For this example, let's keep it simple and demonstrate the core idea.
                # A simple gradient from yellow to red to purple to blue.
                if iterations < max_iter / 4:
                    color = "yellow"
                elif iterations < max_iter / 2:
                    color = "red"
                elif iterations < max_iter * 3 / 4:
                    color = "purple"
                else:
                    color = "blue"

            # Move the turtle to the correct position without drawing.
            # The y-coordinate needs to be flipped because turtle's origin is at the bottom.
            # Also, we need to center the drawing.
            # The screen's y-coordinates range from -SCREEN_HEIGHT/2 to SCREEN_HEIGHT/2.
            # The turtle's y-coordinates range from -SCREEN_HEIGHT/2 to SCREEN_HEIGHT/2.
            # The x-coordinates range from -SCREEN_WIDTH/2 to SCREEN_WIDTH/2.
            # We need to map our pixel coordinates (0 to width, 0 to height) to turtle's coordinate system.
            # For x: 0 -> -SCREEN_WIDTH/2, width -> SCREEN_WIDTH/2
            # For y: 0 -> SCREEN_HEIGHT/2, height -> -SCREEN_HEIGHT/2 (inverted)

            # Calculate turtle's x and y position.
            turtle_x = (x - width / 2)
            turtle_y = (height / 2 - y) # Invert y-axis for turtle

            t.goto(turtle_x, turtle_y)
            t.dot(2, color)  # Draw a dot of size 2 with the calculated color

        screen.update()  # Update the screen after each row to see the drawing progress

# --- Example Usage ---
if __name__ == "__main__":
    # Setup the drawing environment.
    screen, t = setup_turtle()

    # Draw the Mandelbrot set.
    # This is the main call to generate and display the fractal.
    draw_mandelbrot(t, SCREEN_WIDTH, SCREEN_HEIGHT, RE_START, RE_END, IM_START, IM_END, MAX_ITERATIONS)

    # Keep the window open until it's manually closed.
    screen.mainloop()